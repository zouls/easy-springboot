

# Easy-Springboot

基于Springboot框架的各种练习的小demo和实践的代码



## 1. Feature

### 1.1 高并发情况下分布式全局Id生成

2019-09-13



#### 1.1.1 生成分布式全局id策略

1. 注意幂等性且全局唯一性
2. 注意安全性，不能被猜疑
3. 趋势递增性

订单号命名规则:比如“业务编码 + 时间戳 + 机器编号[前4位] + 随机4位数 + 毫秒数”。



#### 1.1.2 UUID

UUID基本概念:UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。

UUID组成部分:当前日期和时间+时钟序列+随机数+全局唯一的IEEE机器识别号

全局唯一的IEEE机器识别号:如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。

UUID优缺点:

优点:

- 简单，代码方便

- 生成ID性能非常好，基本不会有性能问题

- 全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对
- 本地生成，不要基于数据库



缺点:

- **没有排序**，**无法保证趋势递增**

- UUID往往是使用字符串存储，**查询的效率比较低**, uuid太长了，作为主键性能太差了，不适合用于主键

- **存储空间比较大**，如果是海量数据库，就需要考虑存储量的问题
- 传输数据量大

适合的场景：如果你是要随机生成个什么文件名了，编号之类的，你可以用uuid，但是作为主键是不能用uuid的。



#### 1.1.3 基于数据库自增或者序列号

实现思路：利用数据库自增或者序列号方式实现订单号

注意：在数据库集群环境下，默认自增方式存在问题，因为**都是从1开始自增**，可能会存在重复，应该设置每台不同数据库自增的间隔方式不同。

优点:

- 简单，代码方便，性能可以接受。

- 数字ID天然排序，对分页或者需要排序的结果很有帮助。

缺点:

- 不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。

- 在性能达不到要求的情况下，比较难于扩展。

- 在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。

- 分表分库的时候会有麻烦。



##### 1.1.3.1 数据库集群如何考虑数据库自增唯一性

在数据库集群环境下，默认自增方式存在问题，因为都是从1开始自增，可能会存在重复，应该设置每台节点自增步长不同。

查询自增的步长

**SHOW VARIABLES LIKE 'auto_inc%'**

修改自增的步长

**SET @@auto_increment_increment=10;**

修改起始值

**SET @@auto_increment_offset=5;**

假设有两台mysql数据库服务器

节点①自增  1 3 5 7 9 11 ….

节点②自增  2 4 6 8 10 12 ….

注意:在最开始设置好了每台节点自增方式步长后，确定好了mysql集群数量后，无法扩展新的mysql，不然生成步长的规则可能会发生变化。



##### 1.1.3.2 数据库自增id

这个就是说你的系统里每次得到一个id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个id。

拿到这个id之后再往对应的分库分表里去写入。

这个方案的好处就是方便简单，谁都会用；

缺点就是单库生成自增id，要是高并发的话，就会有瓶颈的；

如果你硬是要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前id最大值，然后自己递增几个id，一次性返回一批id，然后再把当前最大id值修改成递增几个id之后的一个值；

但是无论怎么说都是基于单个数据库。

适合的场景：

你分库分表就俩原因，要不就是**单库并发太高**，要不就是**单库数据量太大**；

除非是你并发不高，但是数据量太大导致的分库分表扩容，你可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单独的一个库和表生成自增主键即可。并发很低，几百/s，但是数据量大，几十亿的数据，所以需要靠分库分表来存放海量的数据



### 1.1.4 基于Redis生成生成全局id策略

因为Redis是单线的，天生保证原子性，可以使用Redis的原子操作 INCR和INCRBY来实现

优点:

   不依赖于数据库，灵活方便，且性能优于数据库。

   数字ID天然排序，对分页或者需要排序的结果很有帮助。

缺点:

   如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。

   需要编码和配置的工作量比较大。

注意:在Redis集群情况下，同样和Redis一样需要设置不同的增长步长，同时key一定要设置有效期

可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。各个Redis生成的ID为：

A：1,6,11,16,21

B：2,7,12,17,22

C：3,8,13,18,23

D：4,9,14,19,24

E：5,10,15,20,25

比较适合使用Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。

如果生成的订单号超过自增增长的话，可以采用前缀+自增+并且设置有效期





### 1.1.5 Twitter的Snowflake算法生成全局id

twitter开源的分布式id生成算法，就是把一个64位的long型的id，第1个bit是不用的，用其中的41 bit作为毫秒数，用10 bit作为工作机器id，12 bit作为序列号

1 bit：不用，为啥呢？因为二进制里第一个bit为如果是1，那么都是负数，但是我们生成的id都是正数，所以第一个bit统一都是0

41 bit：表示的是时间戳，单位是毫秒。41 bit可以表示的数字多达2^41 - 1，也就是可以标识2 ^ 41 - 1个毫秒值，换算成年就是表示69年的时间。

10 bit：记录工作机器id，代表的是这个服务最多可以部署在2^10台机器上哪，也就是1024台机器。但是10 bit里5个bit代表机房id，5个bit代表机器id。意思就是最多代表2 ^ 5个机房（32个机房），每个机房里可以代表2 ^ 5个机器（32台机器）。

12 bit：这个是用来记录同一个毫秒内产生的不同id，12 bit可以代表的最大正整数是2 ^ 12 - 1 = 4096，也就是说可以用这个12bit代表的数字来区分同一个毫秒内的4096个不同的id

64位的long型的id，64位的long -> 二进制

0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000

2018-01-01 10:00:00 -> 做了一些计算，再换算成一个二进制

41bit来放 -> 0001100 10100010 10111110 10001001 01011100 00

机房id，17 -> 换算成一个二进制 -> 10001

机器id，25 -> 换算成一个二进制 -> 11001

snowflake算法服务，会判断一下，当前这个请求是否是，机房17的机器25，在2175/11/7 12:12:14时间点发送过来的第一个请求，如果是第一个请求

假设，在2175/11/7 12:12:14时间里，机房17的机器25，发送了第二条消息，snowflake算法服务，会发现说机房17的机器25，在2175/11/7 12:12:14时间里，在这一毫秒，之前已经生成过一个id了，此时如果你同一个机房，同一个机器，在同一个毫秒内，再次要求生成一个id，此时我只能把加1

0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000001


比如我们来观察上面的那个，就是一个典型的二进制的64位的id，换算成10进制就是910499571847892992。



Github地址: https://github.com/twitter-archive/snowflake

Java版本地址: https://github.com/souyunku/SnowFlake

第一位未使用，

接下来的41位为毫秒级时间(41位的长度可以使用69年，从1970-01-01 08:00:00)，

然后是5位datacenterId（最大支持2^5＝32个，二进制表示从00000-11111，也即是十进制0-31），

和5位workerId（最大支持2^5＝32个，原理同datacenterId），所以datacenterId*workerId最多支持部署1024个节点，

最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生2^12＝4096个ID序号）.

所有位数加起来共64位，恰好是一个Long型（转换为字符串长度为18）.

单台机器实例，通过时间戳保证前41位是唯一的，分布式系统多台机器实例下，

通过对每个机器实例分配不同的datacenterId和workerId避免中间的10位碰撞。最后12位每毫秒从0递增生产ID，

再提一次：每毫秒最多生成4096个ID，每秒可达4096000个。





怎么说呢，大概这个意思吧，就是说41 bit，就是当前毫秒单位的一个时间戳，就这意思；然后5 bit是你传递进来的一个机房id（但是最大只能是32以内），5 bit是你传递进来的机器id（但是最大只能是32以内），剩下的那个10 bit序列号，就是如果跟你上次生成id的时间还在一个毫秒内，那么会把顺序给你累加，最多在4096个序号以内。

所以你自己利用这个工具类，自己搞一个服务，然后对每个机房的每个机器都初始化这么一个东西，刚开始这个机房的这个机器的序号就是0。然后每次接收到一个请求，说这个机房的这个机器要生成一个id，你就找到对应的Worker，生成。

他这个算法生成的时候，会把当前毫秒放到41 bit中，然后5 bit是机房id，5 bit是机器id，接着就是判断上一次生成id的时间如果跟这次不一样，序号就自动从0开始；要是上次的时间跟现在还是在一个毫秒内，他就把seq累加1，就是自动生成一个毫秒的不同的序号。

这个算法那，可以确保说每个机房每个机器每一毫秒，最多生成4096个不重复的id。

利用这个snowflake算法，你可以开发自己公司的服务，甚至对于机房id和机器id，反正给你预留了5 bit + 5 bit，你换成别的有业务含义的东西也可以的。

这个snowflake算法相对来说还是比较靠谱的，所以你要真是搞分布式id生成，如果是高并发啥的，那么用这个应该性能比较好，一般每秒几万并发的场景，也足够你用了。



### 1.1.6 基于Zookeeper生成全局id



